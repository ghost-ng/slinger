name: Test Enforcement

on:
  pull_request:
    branches: [main, develop]
    paths:
      - 'src/**/*.py'
      - 'tests/**/*.py'

jobs:
  enforce-tests:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Need full history to check changes
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -e .
    
    - name: Check for new commands without tests
      id: check-commands
      run: |
        # Get list of modified files
        MODIFIED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep '\.py$' || true)
        
        # Check if cli.py was modified
        if echo "$MODIFIED" | grep -q "src/slingerpkg/utils/cli.py"; then
          echo "CLI parser was modified, checking for new commands..."
          
          # Use the validator to check for new commands
          python -c "
        from tests.test_coverage_validator import TestCoverageValidator
        validator = TestCoverageValidator()
        new_commands = validator.check_new_commands('${{ github.base_ref }}')
        if new_commands:
            print(f'NEW_COMMANDS={','.join(new_commands)}')
            with open('new_commands.txt', 'w') as f:
                f.write('\\n'.join(new_commands))
          " >> $GITHUB_OUTPUT
        fi
    
    - name: Check test coverage for modified files
      run: |
        # Get modified Python files
        MODIFIED=$(git diff --name-only origin/${{ github.base_ref }}...HEAD | grep 'src/.*\.py$' || true)
        
        if [ ! -z "$MODIFIED" ]; then
          echo "Modified files:"
          echo "$MODIFIED"
          
          # For each modified file, check if tests exist
          for file in $MODIFIED; do
            # Extract module name
            module=$(basename "$file" .py)
            
            # Check for corresponding test file
            if [ ! -f "tests/unit/test_${module}.py" ] && \
               [ ! -f "tests/integration/test_${module}.py" ]; then
              echo "::warning file=$file::No test file found for $module"
            fi
          done
        fi
    
    - name: Generate test stubs for new commands
      if: steps.check-commands.outputs.NEW_COMMANDS
      run: |
        if [ -f "new_commands.txt" ]; then
          echo "New commands detected, generating test stubs..."
          
          # Create test stubs
          while read cmd; do
            python scripts/generate_test_stub.py "$cmd" || true
          done < new_commands.txt
          
          # Check if stubs were created
          if [ -n "$(git status --porcelain tests/)" ]; then
            echo "::warning::Test stubs generated for new commands. Please implement the tests!"
          fi
        fi
    
    - name: Validate command-test mapping
      run: |
        python tests/test_coverage_validator.py || {
          echo "::error::Not all commands have corresponding tests!"
          exit 1
        }
    
    - name: Check test quality metrics
      run: |
        # Run tests and check metrics
        pytest tests/ --cov=slingerpkg --cov-report=term-missing --cov-fail-under=80 || {
          echo "::error::Test coverage is below 80%!"
          exit 1
        }
    
    - name: Post PR comment with test requirements
      if: failure()
      uses: actions/github-script@v6
      with:
        script: |
          const message = `
          ## ❌ Test Requirements Not Met
          
          This PR modifies code but doesn't meet test requirements:
          
          1. All new commands must have tests
          2. Modified modules should have updated tests
          3. Overall coverage must remain above 80%
          
          Please add the missing tests before merging.
          `;
          
          github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: message
          });